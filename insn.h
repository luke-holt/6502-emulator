#ifndef INSN_H
#define INSN_H

typedef unsigned char u8;

static const char *insnnames[56][2] = {
    [0x00] = {"ADC", "add with carry"},
    [0x01] = {"AND", "and (with accumulator)"},
    [0x02] = {"ASL", "arithmetic shift left"},
    [0x03] = {"BCC", "branch on carry clear"},
    [0x04] = {"BCS", "branch on carry set"},
    [0x05] = {"BEQ", "branch on equal (zero set)"},
    [0x06] = {"BIT", "bit test"},
    [0x07] = {"BMI", "branch on minus (negative set)"},
    [0x08] = {"BNE", "branch on not equal (zero clear)"},
    [0x09] = {"BPL", "branch on plus (negative clear)"},
    [0x0A] = {"BRK", "break / interrupt"},
    [0x0B] = {"BVC", "branch on overflow clear"},
    [0x0C] = {"BVS", "branch on overflow set"},
    [0x0D] = {"CLC", "clear carry"},
    [0x0E] = {"CLD", "clear decimal"},
    [0x0F] = {"CLI", "clear interrupt disable"},
    [0x10] = {"CLV", "clear overflow"},
    [0x11] = {"CMP", "compare (with accumulator)"},
    [0x12] = {"CPX", "compare with X"},
    [0x13] = {"CPY", "compare with Y"},
    [0x14] = {"DEC", "decrement"},
    [0x15] = {"DEX", "decrement X"},
    [0x16] = {"DEY", "decrement Y"},
    [0x17] = {"EOR", "exclusive or (with accumulator)"},
    [0x18] = {"INC", "increment"},
    [0x19] = {"INX", "increment X"},
    [0x1A] = {"INY", "increment Y"},
    [0x1B] = {"JMP", "jump"},
    [0x1C] = {"JSR", "jump subroutine"},
    [0x1D] = {"LDA", "load accumulator"},
    [0x1E] = {"LDX", "load X"},
    [0x1F] = {"LDY", "load Y"},
    [0x20] = {"LSR", "logical shift right"},
    [0x21] = {"NOP", "no operation"},
    [0x22] = {"ORA", "or with accumulator"},
    [0x23] = {"PHA", "push accumulator"},
    [0x24] = {"PHP", "push processor status (SR)"},
    [0x25] = {"PLA", "pull accumulator"},
    [0x26] = {"PLP", "pull processor status (SR)"},
    [0x27] = {"ROL", "rotate left"},
    [0x28] = {"ROR", "rotate right"},
    [0x29] = {"RTI", "return from interrupt"},
    [0x2A] = {"RTS", "return from subroutine"},
    [0x2B] = {"SBC", "subtract with carry"},
    [0x2C] = {"SEC", "set carry"},
    [0x2D] = {"SED", "set decimal"},
    [0x2E] = {"SEI", "set interrupt disable"},
    [0x2F] = {"STA", "store accumulator"},
    [0x30] = {"STX", "store X"},
    [0x31] = {"STY", "store Y"},
    [0x32] = {"TAX", "transfer accumulator to X"},
    [0x33] = {"TAY", "transfer accumulator to Y"},
    [0x34] = {"TSX", "transfer stack pointer to X"},
    [0x35] = {"TXA", "transfer X to accumulator"},
    [0x36] = {"TXS", "transfer X to stack pointer"},
    [0x37] = {"TYA", "transfer Y to accumulator"},
};

// abbreviated, un-abbreviated, syntax, description
static const char *modeinfo[14][4] = {
    [0x0] = {"A",     "Accumulator",         "OPC A",       "operand is AC (implied single byte instruction)"},
    [0x1] = {"abs",   "absolute",            "OPC $LLHH",   "operand is address $HHLL *"},
    [0x2] = {"abs,X", "absolute, X-indexed", "OPC $LLHH,X", "operand is address; effective address is address incremented by X with carry **"},
    [0x3] = {"abs,Y", "absolute, Y-indexed", "OPC $LLHH,Y", "operand is address; effective address is address incremented by Y with carry **"},
    [0x4] = {"#",     "immediate",           "OPC #$BB",    "operand is byte BB"},
    [0x5] = {"impl",  "implied",             "OPC",         "operand implied"},
    [0x6] = {"ind",   "indirect",            "OPC ($LLHH)", "operand is address; effective address is contents of word at address: C.w($HHLL)"},
    [0x7] = {"X,ind", "X-indexed, indirect", "OPC ($LL,X)", "operand is zeropage address; effective address is word in (LL + X, LL + X + 1), inc. without carry: C.w($00LL + X)"},
    [0x8] = {"ind,Y", "indirect, Y-indexed", "OPC ($LL),Y", "operand is zeropage address; effective address is word in (LL, LL + 1) incremented by Y with carry: C.w($00LL) + Y"},
    [0x9] = {"rel",   "relative",            "OPC $BB",     "branch target is PC + signed offset BB ***"},
    [0xA] = {"zpg",   "zeropage",            "OPC $LL",     "operand is zeropage address (hi-byte is zero, address = $00LL)"},
    [0xB] = {"zpg,X", "zeropage, X-indexed", "OPC $LL,X",   "operand is zeropage address; effective address is address incremented by X without carry **"},
    [0xC] = {"zpg,Y", "zeropage, Y-indexed", "OPC $LL,Y",   "operand is zeropage address; effective address is address incremented by Y without carry **"},
    [0xD] = {"n/a",   "invalid",             "n/a",         "invalid addressing mode"},
};

static const u8 modemap[256] = {
    0x5, 0x7, 0xD, 0xD, 0xD, 0xA, 0xA, 0xD, 0x5, 0x4, 0x0, 0xD, 0xD, 0x1, 0x1, 0xD,
    0x9, 0x8, 0xD, 0xD, 0xD, 0xB, 0xB, 0xD, 0x5, 0x3, 0xD, 0xD, 0xD, 0x2, 0x2, 0xD,
    0x1, 0x7, 0xD, 0xD, 0xA, 0xA, 0xA, 0xD, 0x5, 0x4, 0x0, 0xD, 0x1, 0x1, 0x1, 0xD,
    0x9, 0x8, 0xD, 0xD, 0xD, 0xB, 0xB, 0xD, 0x5, 0x3, 0xD, 0xD, 0xD, 0x2, 0x2, 0xD,
    0x5, 0x7, 0xD, 0xD, 0xD, 0xA, 0xA, 0xD, 0x5, 0x4, 0x0, 0xD, 0x1, 0x1, 0x1, 0xD,
    0x9, 0x8, 0xD, 0xD, 0xD, 0xB, 0xB, 0xD, 0x5, 0x3, 0xD, 0xD, 0xD, 0x2, 0x2, 0xD,
    0x5, 0x7, 0xD, 0xD, 0xD, 0xA, 0xA, 0xD, 0x5, 0x4, 0x0, 0xD, 0x8, 0x1, 0x1, 0xD,
    0x9, 0x8, 0xD, 0xD, 0xD, 0xB, 0xB, 0xD, 0x5, 0x3, 0xD, 0xD, 0xD, 0x2, 0x2, 0xD,
    0xD, 0x7, 0xD, 0xD, 0xA, 0xA, 0xA, 0xD, 0x5, 0xD, 0x5, 0xD, 0x1, 0x1, 0x1, 0xD,
    0x9, 0x8, 0xD, 0xD, 0xB, 0xB, 0xC, 0xD, 0x5, 0x3, 0x5, 0xD, 0xD, 0x2, 0xD, 0xD,
    0x4, 0x7, 0x4, 0xD, 0xA, 0xA, 0xA, 0xD, 0x5, 0x4, 0x5, 0xD, 0x1, 0x1, 0x1, 0xD,
    0x9, 0x8, 0xD, 0xD, 0xB, 0xB, 0xC, 0xD, 0x5, 0x3, 0x5, 0xD, 0x2, 0x2, 0x3, 0xD,
    0x4, 0x7, 0xD, 0xD, 0xA, 0xA, 0xA, 0xD, 0x5, 0x4, 0x5, 0xD, 0x1, 0x1, 0x1, 0xD,
    0x9, 0x8, 0xD, 0xD, 0xD, 0xB, 0xB, 0xD, 0x5, 0x3, 0xD, 0xD, 0xD, 0x2, 0x2, 0xD,
    0x4, 0x7, 0xD, 0xD, 0xA, 0xA, 0xA, 0xD, 0x5, 0x4, 0x5, 0xD, 0x1, 0x1, 0x1, 0xD,
    0x9, 0x8, 0xD, 0xD, 0xD, 0xB, 0xB, 0xD, 0x5, 0x3, 0xD, 0xD, 0xD, 0x2, 0x2, 0xD,
};

static const int insnmap[256] = {
    0x0A, 0x22, 0x21, 0x21, 0x21, 0x22, 0x01, 0x21, 0x24, 0x22, 0x01, 0x21, 0x21, 0x22, 0x01, 0x21,
    0x09, 0x22, 0x21, 0x21, 0x21, 0x22, 0x01, 0x21, 0x0D, 0x22, 0x21, 0x21, 0x21, 0x22, 0x01, 0x21,
    0x1C, 0x01, 0x21, 0x21, 0x06, 0x01, 0x27, 0x21, 0x26, 0x01, 0x27, 0x21, 0x06, 0x01, 0x27, 0x21,
    0x07, 0x01, 0x21, 0x21, 0x21, 0x01, 0x27, 0x21, 0x2C, 0x01, 0x21, 0x21, 0x21, 0x01, 0x27, 0x21,
    0x29, 0x17, 0x21, 0x21, 0x21, 0x17, 0x20, 0x21, 0x23, 0x17, 0x20, 0x21, 0x1B, 0x17, 0x20, 0x21,
    0x0B, 0x17, 0x21, 0x21, 0x21, 0x17, 0x20, 0x21, 0x0F, 0x17, 0x21, 0x21, 0x21, 0x17, 0x20, 0x21,
    0x2A, 0x00, 0x21, 0x21, 0x21, 0x00, 0x28, 0x21, 0x25, 0x00, 0x28, 0x21, 0x1B, 0x00, 0x28, 0x21,
    0x0C, 0x00, 0x21, 0x21, 0x21, 0x00, 0x28, 0x21, 0x2E, 0x00, 0x21, 0x21, 0x21, 0x00, 0x28, 0x21,
    0x21, 0x2F, 0x21, 0x21, 0x31, 0x2F, 0x31, 0x21, 0x16, 0x21, 0x35, 0x21, 0x31, 0x2F, 0x31, 0x21,
    0x03, 0x2F, 0x21, 0x21, 0x31, 0x2F, 0x31, 0x21, 0x37, 0x2F, 0x36, 0x21, 0x21, 0x2F, 0x21, 0x21,
    0x1F, 0x1D, 0x1E, 0x21, 0x1F, 0x1D, 0x1E, 0x21, 0x33, 0x1D, 0x32, 0x21, 0x1F, 0x1D, 0x1E, 0x21,
    0x04, 0x1D, 0x21, 0x21, 0x1F, 0x1D, 0x1E, 0x21, 0x10, 0x1D, 0x34, 0x21, 0x1F, 0x1D, 0x1E, 0x21,
    0x13, 0x11, 0x21, 0x21, 0x13, 0x11, 0x14, 0x21, 0x1A, 0x11, 0x15, 0x21, 0x13, 0x11, 0x14, 0x21,
    0x08, 0x11, 0x21, 0x21, 0x21, 0x11, 0x14, 0x21, 0x0E, 0x11, 0x21, 0x21, 0x21, 0x11, 0x14, 0x21,
    0x12, 0x2B, 0x21, 0x21, 0x12, 0x2B, 0x18, 0x21, 0x19, 0x2B, 0x21, 0x21, 0x12, 0x2B, 0x18, 0x21,
    0x05, 0x2B, 0x21, 0x21, 0x21, 0x2B, 0x18, 0x21, 0x2D, 0x2B, 0x21, 0x21, 0x21, 0x2B, 0x18, 0x21,
};

#endif // INSN_H
